---
lastUpdated: false
---

## 事件捕获，事件冒泡，事件委托

- DOM 事件模型分为两种 ， 事件捕获和事件冒泡
  - 事件捕获是从外向内触发 ， 根——目标元素
  - 事件冒泡是从内向外触发 ， 目标元素——根
- 事件传播
  - 无论是捕捉还是冒泡都有传播阶段 ， 传播阶段就是事件从出发开始到结束的过程
    - 优先级 ：先捕获，在冒泡
- 事件冒泡是如何工作的？
  - 在一个元素上触发某些事件 ， 这个事件就会向父级对象传播 ， 从内至外 ， 直到事件被处理 ， 而父级对象的所有同类事件都将被激活 。或者到达了浏览器的顶级对象（window/document）
  - 阻止方式 ： event.stopPropagation()
- 缺点
  - 在页面嵌套多层的情况下 ， 处理效率很低
- 优点
  - 不用频繁的为每个元素单独注册事件

## 重绘和回流

- 重绘
  - 元素的一部分属性发生改变（颜色，外观，背景）等不会引起布局变化，只需要浏览器根据元素的新属性重新绘制，使元素呈现新的外观
- 回流
  - 当 render 树的一部分或者全部因为位置，大小边距等问题发生改变从而使 DOM 树重新计算的过程
- 重绘不一定回流，但回流一定会重绘

- 最小化重绘和回流
  - 对元素进行复杂操作时先隐藏，操作完成后在显示
  - 需要创建多个 DOM 节点时可以使用 **文档碎片（DocumenFragment）**创建完成后一次性加入 document
  - 避免 table 布局
  - css 使用属性简写
  - 批量修改元素样式

## This 指向

- 函数形式调用 ， this 永远都是 window
- 对象形式调用 ， this 是调用方法的对象
- 构造函数形式调用 ， this 指向新创建的那个对象
- call，apply 调用 ， this 指向指定对象
- 箭头函数本身没有this ， 外层有函数就指向外层 ， 如果外层是 window 就指向 window

## call apply bind 区别

- 共同点
  - 都是改变函数的 this 指向
  - 第一个参数都是 this 指向的对象 , 如果是 null 或者是 undefined 则指向window
- 不同点
  - apply 接受的数组 ， call 接受的参数列表 ， 这两者可以一次性传参， 但是 bind 可以分多次传递
  - bind 返回绑定 this 之后的函数 ， apply 和 call 则是立即执行

## 防抖和节流

- 防抖
  - 持续触发事件 ， 一定时间内没有触发，函数执行一次
- 节流
  - 持续触发事件 ， 一定时间内只触发一次 ， 可以多次触发



## new 操作符具体题做了些什么

- 创建一个空对象
- 将 this 指向空对象 ， 将构造函数的作用域赋值给空对象
- 执行构造函数中的代码，为空对象添加属性
- 返回新对象
