import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.cc2b3d55.js";
const __pageData = JSON.parse('{"title":"浏览器的进程模型","description":"过去把消息队列简单分为宏队列和微队列 , 这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式.","frontmatter":{"title":"浏览器的进程模型","description":"过去把消息队列简单分为宏队列和微队列 , 这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式.","sticky":1,"tag":["前端进阶"],"outline":[2,3],"top":1},"headers":[],"relativePath":"msgLoop.md","filePath":"msgLoop.md","lastUpdated":1687591992000}');
const _sfc_main = { name: "msgLoop.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h2 id="进程" tabindex="-1">进程 <a class="header-anchor" href="#进程" aria-label="Permalink to &quot;进程&quot;">​</a></h2><p>程序运行需要有自己的专属空间 , 这块内存空间可以简单的理解为进程 . 每个应用至少有一个进程 , 进程之间是相互独立的 , 即便要通信也得双方同意 . 如果进程之间不独立 , 可能会造成连环崩溃 .</p><h2 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to &quot;线程&quot;">​</a></h2><p>一个进程至少有一个线程 , 进程开启时会自动创建一个主线程来运行代码 , 如果需要同时执行多块代码 , 主线程就会启动更多的线程来执行代码 .</p><h2 id="浏览器的进程和线程" tabindex="-1">浏览器的进程和线程 <a class="header-anchor" href="#浏览器的进程和线程" aria-label="Permalink to &quot;浏览器的进程和线程&quot;">​</a></h2><p>浏览器是一个多线程多进程的应用 , 为了避免相互影响 , 以及减少连环崩溃 , 所以启用了很多的进程 其中最重要的进程有三个 : <strong>1.浏览器进程 ; 2.网络进程 ; 3.渲染进程</strong></p><h3 id="_1-浏览器进程" tabindex="-1">1.浏览器进程 <a class="header-anchor" href="#_1-浏览器进程" aria-label="Permalink to &quot;1.浏览器进程&quot;">​</a></h3><p>主要负责界面展示 , 这个界面展示不是 dom , 而是浏览器的默认功能展示 , 例如书签栏和前进后退刷新</p><h3 id="_2-网络进程" tabindex="-1">2.网络进程 <a class="header-anchor" href="#_2-网络进程" aria-label="Permalink to &quot;2.网络进程&quot;">​</a></h3><p>负责加载网络资源 , 网络进程内部会启动多个线程来处理不同的网络任务</p><h3 id="_3-渲染进程-★★★" tabindex="-1">3.渲染进程(★★★) <a class="header-anchor" href="#_3-渲染进程-★★★" aria-label="Permalink to &quot;3.渲染进程(★★★)&quot;">​</a></h3><p>启动后会自动开启一个**渲染主线程 , **主要负责执行 HTML , CSS , JS 等标签和代码 . 默认情况下 , 浏览器会为每个标签开启一个新的渲染进程 , 保证不同的标签页之间不互相影响 . 但在之后可能会更改这种渲染模式 , 因为很吃内存, 可能会更改为一个站点一个标签页 . ps : 事件循环就是在 <strong>渲染主线程</strong> 进行的</p><h2 id="渲染主线程的工作" tabindex="-1">渲染主线程的工作 <a class="header-anchor" href="#渲染主线程的工作" aria-label="Permalink to &quot;渲染主线程的工作&quot;">​</a></h2><ul><li>解析 HTML</li><li>解析 CSS</li><li>计算样式 ( 转换成 px , 权重的样式)</li><li>布局 ( 计算几何信息 )</li><li>处理图层 ( z-index 的优先级 )</li><li>每秒渲染画面(60pfs)</li><li>执行全局 JS 代码</li><li>执行事件处理函数</li><li>执行计时器的回调</li><li>...等等<div class="info custom-block"><p class="custom-block-title">INFO</p><p>思考:为什么渲染进程不适用多个线程来处理这些事情?</p></div></li></ul><h2 id="渲染主线程的调度任务" tabindex="-1">渲染主线程的调度任务 <a class="header-anchor" href="#渲染主线程的调度任务" aria-label="Permalink to &quot;渲染主线程的调度任务&quot;">​</a></h2><p>主要的就是采用<strong>排队机制</strong>来执行调度任务 <img src="https://cdn.nlark.com/yuque/0/2023/jpeg/34997670/1681282803386-1d4edc94-29f2-43c4-b3ba-8e6f2584cce4.jpeg" alt=""> 在 W3C 中 , 叫 event loop , 事件循环 , 但是在谷歌浏览器中叫 message loop 消息循环 主要流程</p><ul><li>在最开始的时候 , 渲染主线程会进入到一个无限循环</li><li>每一次循环就会检查消息队列中是否有任务存在 . 如果有就取出第一个任务执行 , 执行完一个之后进入下一次的循环 ; 如果没有 , 就进入休眠状态 .</li><li>其他所有线程 (包括其他进程的线程) 可以随时向消息队列中添加任务 , 新任务会加到消息队列的末尾 . 添加任务时如果主线程是休眠状态 , 则会将其唤醒以继续循环拿取任务</li><li>这样整个过程就是<strong>事件循环 (消息循环)</strong></li></ul><h2 id="事件循环的一些细节" tabindex="-1">事件循环的一些细节 <a class="header-anchor" href="#事件循环的一些细节" aria-label="Permalink to &quot;事件循环的一些细节&quot;">​</a></h2><h3 id="异步" tabindex="-1">异步 <a class="header-anchor" href="#异步" aria-label="Permalink to &quot;异步&quot;">​</a></h3><ul><li>定时器任务</li><li>网络通信完成后需要执行的任务</li><li>用户操作后执行的任务</li></ul><p>主要是用来解决浏览器<strong>阻塞 , <strong>如果让渲染主线程等待这些任务的实际达到 , 就会导致主线程长期处于</strong>阻塞</strong>的状态 , 导致浏览器卡死 .</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>面试题 : 如何理解 JS 的异步? JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。 所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p></div><h2 id="任务优先级" tabindex="-1">任务优先级 <a class="header-anchor" href="#任务优先级" aria-label="Permalink to &quot;任务优先级&quot;">​</a></h2><p>任务没有优先级 , 采用<strong>先进先出</strong>的方式 . 但是**消息队列有优先级 **. W3C 最新解释</p><ul><li><p>每个任务都有一个任务类型 , 同一个类型的任务必须在一个队列 , 不同类型的任务科尔而已分属于不同的队列 . 在一次时间循环中 , 浏览器可以根据实际情况从不同的队列中取出任务执行.</p></li><li><p>浏览器必须准备好一个微队列 , 微队列中的任务优先所有的其他任务执行</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>随着浏览器复杂度提升 , W3C 不再使用宏队列的说法</p></div><p>目前的谷歌浏览器中 , 至少包含了以下队列 (还有其他队列但无需了解)</p></li><li><p>延时队列 : 用于存放计时器计时完成后的回调任务 , 优先级 <strong>中</strong></p></li><li><p>交互队列 : 用于存放用户操作后产生的事件处理任务, 优先级 <strong>高</strong></p></li><li><p>微队列 : 用户存放需要最快执行的任务, 优先级 <strong>最高</strong></p><ul><li>添加到微队列的主要方式是 Promise 、MutationObserveer</li></ul></li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="${ssrRenderStyle({ "color": "#676E95", "font-style": "italic" })}">// 函数直接被添加到微队列</span></span>
<span class="line"><span style="${ssrRenderStyle({ "color": "#FFCB6B" })}">Promise</span><span style="${ssrRenderStyle({ "color": "#89DDFF" })}">.</span><span style="${ssrRenderStyle({ "color": "#82AAFF" })}">resolve</span><span style="${ssrRenderStyle({ "color": "#A6ACCD" })}">()</span><span style="${ssrRenderStyle({ "color": "#89DDFF" })}">.</span><span style="${ssrRenderStyle({ "color": "#82AAFF" })}">then</span><span style="${ssrRenderStyle({ "color": "#A6ACCD" })}">(函数)</span></span></code></pre></div><h2 id="阐述-js-的事件循环" tabindex="-1">阐述 JS 的事件循环 <a class="header-anchor" href="#阐述-js-的事件循环" aria-label="Permalink to &quot;阐述 JS 的事件循环&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">INFO</p><p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。 根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p></div><p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/34997670/1681369952043-86708d9b-941a-48fd-9918-5c28f684f8ac.jpeg" alt=""></p><h2 id="js-中的计时器能做到精确计时么-为什么" tabindex="-1">JS 中的计时器能做到精确计时么?为什么? <a class="header-anchor" href="#js-中的计时器能做到精确计时么-为什么" aria-label="Permalink to &quot;JS 中的计时器能做到精确计时么?为什么?&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">1.计算机硬件没有原子钟，无法做到精确计时. 2.操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差 3.按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差 4.受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</p></div></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("msgLoop.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const msgLoop = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  msgLoop as default
};
